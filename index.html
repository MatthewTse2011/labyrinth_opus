<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Labyrinth</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  overscroll-behavior: none; touch-action: none;
  user-select: none; -webkit-user-select: none;
  background: #1a0e08;
  font-family: Georgia, 'Times New Roman', serif;
}
body {
  display: flex; flex-direction: column;
  align-items: center; padding-top: 8px;
}
#hud {
  display: flex; justify-content: space-between;
  align-items: center; width: 100%; max-width: 420px;
  padding: 4px 10px 8px; color: #dcc49c;
}
.hud-item { text-align: center; flex: 1; }
.hud-label { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; }
.hud-value { font-size: 16px; font-weight: bold; margin-top: 1px; }
canvas {
  display: block; border-radius: 4px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10,5,2,0.84);
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  z-index: 100; color: #dcc49c; text-align: center; padding: 30px;
}
.overlay.hidden { display: none; }
.overlay h1 { font-size: 36px; margin-bottom: 6px; text-shadow: 0 2px 10px rgba(0,0,0,0.6); }
.overlay h2 { font-size: 28px; margin-bottom: 10px; }
.overlay p { font-size: 16px; margin: 6px 0; line-height: 1.6; opacity: 0.9; }
.overlay .sub { font-size: 13px; opacity: 0.55; margin-top: 4px; }
.time-display {
  font-size: 48px; color: #f0c040; margin: 12px 0;
  font-weight: bold; text-shadow: 0 0 24px rgba(240,192,64,0.3);
}
.btn {
  padding: 16px 48px; font-size: 18px;
  background: linear-gradient(180deg, #a0622a, #7a4420);
  color: #f5e6d0; border: 2px solid #c8a060;
  border-radius: 14px; cursor: pointer;
  font-family: Georgia, serif; margin-top: 18px;
  -webkit-tap-highlight-color: transparent;
  box-shadow: 0 4px 14px rgba(0,0,0,0.4);
}
.btn:active { background: linear-gradient(180deg,#7a4420,#5a3010); transform: scale(0.97); }
</style>
</head>
<body>

<div id="hud">
  <div class="hud-item"><div class="hud-label">Lives</div><div class="hud-value" id="hudLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div></div>
  <div class="hud-item"><div class="hud-label">Time</div><div class="hud-value" id="hudTime">0.0s</div></div>
  <div class="hud-item"><div class="hud-label">Keys</div><div class="hud-value" id="hudKeys">üîë 0/3</div></div>
  <div class="hud-item"><div class="hud-label">Level</div><div class="hud-value" id="hudLevel">1</div></div>
</div>
<canvas id="gameCanvas"></canvas>

<div class="overlay" id="overlayStart">
  <h1>‚öôÔ∏è Labyrinth</h1>
  <p>Tilt your phone to roll the steel ball<br>through the maze to the goal.</p>
  <p>Collect all 3 üîë keys to unlock the exit!<br>Avoid the holes! You have 3 lives.</p>
  <p class="sub">Hold your phone however feels comfortable ‚Äî<br>that angle becomes your neutral position.</p>
  <button class="btn" id="btnStart">Tap to Start</button>
</div>
<div class="overlay hidden" id="overlayFell">
  <h2>üòµ Fell in a hole!</h2>
  <p id="fellMsg">Lives remaining: ‚ù§Ô∏è‚ù§Ô∏è</p>
  <p class="sub">Keys have been scattered again!</p>
  <button class="btn" id="btnRetry">Try Again</button>
</div>
<div class="overlay hidden" id="overlayWin">
  <h2>üéâ Level Complete!</h2>
  <div class="time-display" id="winTime">0.0s</div>
  <p id="winMsg"></p>
  <button class="btn" id="btnNext">Next Level</button>
</div>
<div class="overlay hidden" id="overlayGameOver">
  <h2>üíÄ Game Over</h2>
  <p>All lives lost!</p>
  <button class="btn" id="btnRestart">Start Over</button>
</div>
<div class="overlay hidden" id="overlayAllDone">
  <h2>üèÜ You Win!</h2>
  <p>All 3 levels completed!</p>
  <div class="time-display" id="totalTimeVal">0.0s</div>
  <p class="sub">Total time across all levels</p>
  <button class="btn" id="btnPlayAgain">Play Again</button>
</div>

<script>
var canvas = document.getElementById('gameCanvas');
var ctx = canvas.getContext('2d');

var OPEN = 0, WALL = 1, HOLE = 2, START = 3, END = 4;

var LEVELS = [
  [[1,1,1,1,1,1,1,1],
   [1,3,0,0,0,0,0,1],
   [1,1,1,1,1,1,0,1],
   [1,0,0,0,0,0,0,1],
   [1,0,1,1,1,1,1,1],
   [1,0,0,2,0,0,0,1],
   [1,1,0,1,1,1,0,1],
   [1,0,0,0,0,2,0,1],
   [1,0,1,1,1,1,0,1],
   [1,0,0,0,0,0,4,1],
   [1,1,1,1,1,1,1,1]],

  [[1,1,1,1,1,1,1,1,1,1],
   [1,3,0,0,1,0,0,0,0,1],
   [1,1,1,0,1,0,1,1,0,1],
   [1,0,0,0,0,0,1,0,0,1],
   [1,0,1,1,1,0,1,0,1,1],
   [1,0,0,2,0,0,0,0,0,1],
   [1,0,1,1,1,1,1,1,0,1],
   [1,0,0,0,0,0,2,0,0,1],
   [1,1,1,0,1,1,1,1,0,1],
   [1,0,0,0,1,0,0,0,0,1],
   [1,0,1,0,1,0,1,1,1,1],
   [1,0,1,0,0,0,0,0,4,1],
   [1,1,1,1,1,1,1,1,1,1]],

  [[1,1,1,1,1,1,1,1,1,1],
   [1,3,0,0,1,0,0,0,0,1],
   [1,0,1,0,0,0,1,1,0,1],
   [1,0,1,1,1,0,0,0,0,1],
   [1,0,0,0,1,0,1,0,1,1],
   [1,1,1,0,1,2,1,0,0,1],
   [1,0,0,0,0,0,1,1,0,1],
   [1,0,1,1,1,0,0,2,0,1],
   [1,0,1,0,0,0,1,1,0,1],
   [1,0,0,0,1,2,0,0,0,1],
   [1,0,1,0,1,1,1,0,1,1],
   [1,0,1,0,2,0,0,0,0,1],
   [1,0,1,1,1,0,1,1,0,1],
   [1,0,0,2,0,0,0,0,4,1],
   [1,1,1,1,1,1,1,1,1,1]]
];

// Tuning
var FRICTION = 0.965;
var ACCEL = 0.5;
var SENSITIVITY_X = 1.0;
var SENSITIVITY_Y = 1.4;
var MAX_SPEED = 5;
var BOUNCE_FACTOR = 0.25;
var HOLE_PULL_RADIUS = 0.85;
var HOLE_PULL_STRENGTH = 0.1;
var HOLE_FALL_RADIUS = 0.26;
var KEY_COLLECT_RADIUS = 0.45;

// State
var currentLevel = 0;
var lives = 3;
var gameState = 'start';
var timerStart = 0;
var timerRunning = false;
var totalTime = 0;

var cellSize = 0;
var maze = null;
var ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 0 };
var holes = [];
var startPos = { x: 0, y: 0 };
var endPos = { x: 0, y: 0 };

var gameKeys = [];
var collectedKeys = 0;
var exitUnlocked = false;
var keyCollectAnims = [];
var onExitZone = false;

var messageTimer = 0;
var messageText = '';
var shakeTimer = 0;

var tiltX = 0, tiltY = 0;
var calibrated = false;
var betaOffset = 0, gammaOffset = 0;
var orientationListening = false;

var fallAnim = null;
var bgCanvas = null, bgCtx = null;
var lastTimestamp = 0;

// ============================================================
function setupCanvas() {
  maze = LEVELS[currentLevel];
  var rows = maze.length;
  var cols = maze[0].length;
  var maxW = Math.min(window.innerWidth - 8, 420);
  var maxH = window.innerHeight - 80;
  cellSize = Math.floor(Math.min(maxW / cols, maxH / rows));
  canvas.width = cellSize * cols;
  canvas.height = cellSize * rows;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  ball.radius = Math.floor(cellSize * 0.32);
}

function spawnKeys() {
  gameKeys = [];
  collectedKeys = 0;
  exitUnlocked = false;
  keyCollectAnims = [];
  onExitZone = false;

  var openCells = [];
  for (var r = 0; r < maze.length; r++) {
    for (var c = 0; c < maze[0].length; c++) {
      if (maze[r][c] === OPEN) {
        var px = c * cellSize + cellSize / 2;
        var py = r * cellSize + cellSize / 2;
        var dsX = px - startPos.x, dsY = py - startPos.y;
        var deX = px - endPos.x, deY = py - endPos.y;
        if (Math.sqrt(dsX * dsX + dsY * dsY) > cellSize * 1.5 &&
            Math.sqrt(deX * deX + deY * deY) > cellSize * 1.5) {
          openCells.push({ x: px, y: py });
        }
      }
    }
  }

  for (var i = openCells.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = openCells[i]; openCells[i] = openCells[j]; openCells[j] = tmp;
  }

  var chosen = [];
  for (var k = 0; k < openCells.length && chosen.length < 3; k++) {
    var cell = openCells[k];
    var tooClose = false;
    for (var h = 0; h < holes.length; h++) {
      var dhx = cell.x - holes[h].x, dhy = cell.y - holes[h].y;
      if (Math.sqrt(dhx * dhx + dhy * dhy) < cellSize * 1.2) {
        tooClose = true; break;
      }
    }
    if (!tooClose) chosen.push(cell);
  }
  if (chosen.length < 3) {
    for (var k = 0; k < openCells.length && chosen.length < 3; k++) {
      var already = false;
      for (var c2 = 0; c2 < chosen.length; c2++) {
        if (chosen[c2].x === openCells[k].x && chosen[c2].y === openCells[k].y) {
          already = true; break;
        }
      }
      if (!already) chosen.push(openCells[k]);
    }
  }
  for (var k = 0; k < chosen.length; k++) {
    gameKeys.push({ x: chosen[k].x, y: chosen[k].y, collected: false });
  }
}

function initLevel() {
  setupCanvas();
  holes = [];
  for (var r = 0; r < maze.length; r++) {
    for (var c = 0; c < maze[0].length; c++) {
      var px = c * cellSize + cellSize / 2;
      var py = r * cellSize + cellSize / 2;
      var val = maze[r][c];
      if (val === START) startPos = { x: px, y: py };
      else if (val === END) endPos = { x: px, y: py };
      else if (val === HOLE) holes.push({ x: px, y: py });
    }
  }
  spawnKeys();
  resetBall();
  renderBackground();
  updateHUD();
}

function resetBall() {
  ball.x = startPos.x;
  ball.y = startPos.y;
  ball.vx = 0;
  ball.vy = 0;
  fallAnim = null;
  messageTimer = 0;
  shakeTimer = 0;
  onExitZone = false;
}

// ============================================================
// BACKGROUND (static: floor, walls, holes)
// ============================================================
function renderBackground() {
  bgCanvas = document.createElement('canvas');
  bgCanvas.width = canvas.width;
  bgCanvas.height = canvas.height;
  bgCtx = bgCanvas.getContext('2d');

  bgCtx.fillStyle = '#c49a6c';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
  for (var y = 0; y < bgCanvas.height; y++) {
    var n = Math.sin(y * 0.15) * 0.03 + Math.sin(y * 0.4 + 1.5) * 0.015
          + Math.sin(y * 0.02 + 0.7) * 0.04;
    bgCtx.fillStyle = n > 0
      ? 'rgba(80,50,15,' + Math.abs(n) + ')'
      : 'rgba(220,196,156,' + Math.abs(n) + ')';
    bgCtx.fillRect(0, y, bgCanvas.width, 1);
  }

  for (var r = 0; r < maze.length; r++) {
    for (var c = 0; c < maze[0].length; c++) {
      if (maze[r][c] !== WALL) continue;
      var x = c * cellSize, y = r * cellSize;
      bgCtx.fillStyle = 'rgba(0,0,0,0.2)';
      bgCtx.fillRect(x + 2, y + 2, cellSize, cellSize);
      bgCtx.fillStyle = '#5a3015';
      bgCtx.fillRect(x, y, cellSize, cellSize);
      for (var g = 0; g < cellSize; g += 3) {
        var gn = Math.sin((y + g) * 0.2) * 0.04 + Math.sin((y + g) * 0.07) * 0.02;
        bgCtx.fillStyle = 'rgba(0,0,0,' + Math.abs(gn) + ')';
        bgCtx.fillRect(x, y + g, cellSize, 2);
      }
      bgCtx.fillStyle = 'rgba(180,130,80,0.25)';
      bgCtx.fillRect(x, y, cellSize, 2);
      bgCtx.fillRect(x, y, 2, cellSize);
      bgCtx.fillStyle = 'rgba(0,0,0,0.25)';
      bgCtx.fillRect(x + 2, y + cellSize - 2, cellSize - 2, 2);
      bgCtx.fillRect(x + cellSize - 2, y + 2, 2, cellSize - 2);
    }
  }

  holes.forEach(function(h) {
    var hr = cellSize * 0.34;
    var g1 = bgCtx.createRadialGradient(h.x, h.y, hr * 0.7, h.x, h.y, hr * 1.3);
    g1.addColorStop(0, 'rgba(0,0,0,0.3)');
    g1.addColorStop(1, 'rgba(0,0,0,0)');
    bgCtx.beginPath(); bgCtx.arc(h.x, h.y, hr * 1.3, 0, Math.PI * 2);
    bgCtx.fillStyle = g1; bgCtx.fill();
    var g2 = bgCtx.createRadialGradient(h.x, h.y, 0, h.x, h.y, hr);
    g2.addColorStop(0, '#050202'); g2.addColorStop(0.6, '#0a0504');
    g2.addColorStop(0.85, '#1a0e08'); g2.addColorStop(1, '#3a2010');
    bgCtx.beginPath(); bgCtx.arc(h.x, h.y, hr, 0, Math.PI * 2);
    bgCtx.fillStyle = g2; bgCtx.fill();
    bgCtx.strokeStyle = 'rgba(30,15,5,0.5)'; bgCtx.lineWidth = 1.5; bgCtx.stroke();
  });

  bgCtx.strokeStyle = '#1a0a04'; bgCtx.lineWidth = 3;
  bgCtx.strokeRect(1, 1, bgCanvas.width - 2, bgCanvas.height - 2);
}

// ============================================================
// DYNAMIC DRAWING: exit, keys, message
// ============================================================
function drawExit(timestamp) {
  var gr = cellSize * 0.36;

  if (exitUnlocked) {
    var pulse = Math.sin(timestamp * 0.005) * 0.5 + 0.5;
    var glowR = gr * 1.3 + pulse * gr * 0.5;
    var gg1 = ctx.createRadialGradient(endPos.x, endPos.y, 0, endPos.x, endPos.y, glowR);
    gg1.addColorStop(0, 'rgba(80,255,80,' + (0.18 + pulse * 0.12) + ')');
    gg1.addColorStop(0.5, 'rgba(180,255,100,' + (0.08 + pulse * 0.06) + ')');
    gg1.addColorStop(1, 'rgba(255,255,80,0)');
    ctx.beginPath(); ctx.arc(endPos.x, endPos.y, glowR, 0, Math.PI * 2);
    ctx.fillStyle = gg1; ctx.fill();

    var gg2 = ctx.createRadialGradient(endPos.x - gr * 0.3, endPos.y - gr * 0.3, gr * 0.1,
      endPos.x + gr * 0.1, endPos.y + gr * 0.1, gr);
    gg2.addColorStop(0, '#ffe880'); gg2.addColorStop(0.5, '#d4a020'); gg2.addColorStop(1, '#906c10');
    ctx.beginPath(); ctx.arc(endPos.x, endPos.y, gr, 0, Math.PI * 2);
    ctx.fillStyle = gg2; ctx.fill();
    ctx.strokeStyle = '#40c040'; ctx.lineWidth = 2.5; ctx.stroke();

    ctx.font = Math.floor(cellSize * 0.42) + 'px serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('üèÅ', endPos.x, endPos.y);
  } else {
    var pulse = Math.sin(timestamp * 0.003) * 0.5 + 0.5;
    var glowR = gr * 1.1 + pulse * gr * 0.1;
    var gg1 = ctx.createRadialGradient(endPos.x, endPos.y, 0, endPos.x, endPos.y, glowR);
    gg1.addColorStop(0, 'rgba(255,200,80,' + (0.04 + pulse * 0.02) + ')');
    gg1.addColorStop(1, 'rgba(255,200,80,0)');
    ctx.beginPath(); ctx.arc(endPos.x, endPos.y, glowR, 0, Math.PI * 2);
    ctx.fillStyle = gg1; ctx.fill();

    var gg2 = ctx.createRadialGradient(endPos.x - gr * 0.3, endPos.y - gr * 0.3, gr * 0.1,
      endPos.x + gr * 0.1, endPos.y + gr * 0.1, gr);
    gg2.addColorStop(0, '#a09070'); gg2.addColorStop(0.5, '#786048'); gg2.addColorStop(1, '#504028');
    ctx.beginPath(); ctx.arc(endPos.x, endPos.y, gr, 0, Math.PI * 2);
    ctx.fillStyle = gg2; ctx.fill();
    ctx.strokeStyle = '#483820'; ctx.lineWidth = 1.5; ctx.stroke();

    ctx.font = Math.floor(cellSize * 0.36) + 'px serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('üîí', endPos.x, endPos.y);
  }
}

function drawKeys(timestamp) {
  for (var i = 0; i < gameKeys.length; i++) {
    if (gameKeys[i].collected) continue;
    var k = gameKeys[i];
    var bob = Math.sin(timestamp * 0.004 + i * 2.1) * cellSize * 0.06;

    var glowR = cellSize * 0.42;
    var glow = ctx.createRadialGradient(k.x, k.y + bob, 0, k.x, k.y + bob, glowR);
    glow.addColorStop(0, 'rgba(255,220,60,0.3)');
    glow.addColorStop(1, 'rgba(255,220,60,0)');
    ctx.beginPath(); ctx.arc(k.x, k.y + bob, glowR, 0, Math.PI * 2);
    ctx.fillStyle = glow; ctx.fill();

    ctx.font = Math.floor(cellSize * 0.5) + 'px serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('üîë', k.x, k.y + bob);
  }

  for (var i = keyCollectAnims.length - 1; i >= 0; i--) {
    var anim = keyCollectAnims[i];
    var t = (timestamp - anim.startTime) / anim.duration;
    if (t >= 1) { keyCollectAnims.splice(i, 1); continue; }
    var scale = 1 + t * 1.5;
    var alpha = 1 - t;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = Math.floor(cellSize * 0.5 * scale) + 'px serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('üîë', anim.x, anim.y - t * cellSize * 0.7);
    ctx.restore();
  }
}

function drawMessage() {
  if (messageTimer <= 0) return;
  var alpha = Math.min(1, messageTimer / 400);
  ctx.save();
  ctx.globalAlpha = alpha;

  var fontSize = Math.max(13, Math.floor(cellSize * 0.34));
  ctx.font = 'bold ' + fontSize + 'px Georgia';
  var tw = ctx.measureText(messageText).width;
  var boxW = tw + 32;
  var boxH = fontSize + 22;
  var boxX = canvas.width / 2 - boxW / 2;
  var boxY = canvas.height / 2 - boxH / 2 - cellSize;

  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  ctx.beginPath();
  roundRect(ctx, boxX, boxY, boxW, boxH, 10);
  ctx.fill();
  ctx.strokeStyle = 'rgba(200,160,80,0.5)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  roundRect(ctx, boxX, boxY, boxW, boxH, 10);
  ctx.stroke();

  ctx.fillStyle = '#f0c040';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(messageText, canvas.width / 2, boxY + boxH / 2);
  ctx.restore();
}

function roundRect(c, x, y, w, h, r) {
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.arcTo(x + w, y, x + w, y + r, r);
  c.lineTo(x + w, y + h - r);
  c.arcTo(x + w, y + h, x + w - r, y + h, r);
  c.lineTo(x + r, y + h);
  c.arcTo(x, y + h, x, y + h - r, r);
  c.lineTo(x, y + r);
  c.arcTo(x, y, x + r, y, r);
}

// ============================================================
// BALL RENDERING
// ============================================================
function drawBall(x, y, r) {
  if (r <= 0) return;
  ctx.beginPath(); ctx.arc(x + 2, y + 3, r * 0.95, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fill();
  var g = ctx.createRadialGradient(x - r * 0.3, y - r * 0.35, r * 0.05,
    x + r * 0.1, y + r * 0.1, r);
  g.addColorStop(0, '#eeeeF4'); g.addColorStop(0.2, '#ccccDC');
  g.addColorStop(0.5, '#8888A0'); g.addColorStop(0.8, '#505068');
  g.addColorStop(1, '#2a2a38');
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fillStyle = g; ctx.fill();
  ctx.beginPath(); ctx.arc(x - r * 0.22, y - r * 0.25, r * 0.17, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.65)'; ctx.fill();
}

// ============================================================
// PHYSICS
// ============================================================
function updatePhysics(timestamp) {
  ball.vx += tiltX * ACCEL * SENSITIVITY_X;
  ball.vy += tiltY * ACCEL * SENSITIVITY_Y;

  for (var i = 0; i < holes.length; i++) {
    var h = holes[i];
    var dx = h.x - ball.x, dy = h.y - ball.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var pullR = cellSize * HOLE_PULL_RADIUS;
    if (dist < pullR && dist > 1) {
      var str = HOLE_PULL_STRENGTH * (1 - dist / pullR);
      ball.vx += (dx / dist) * str;
      ball.vy += (dy / dist) * str;
    }
  }

  ball.vx *= FRICTION;
  ball.vy *= FRICTION;
  var spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (spd > MAX_SPEED) { ball.vx *= MAX_SPEED / spd; ball.vy *= MAX_SPEED / spd; }
  if (Math.abs(ball.vx) < 0.005) ball.vx = 0;
  if (Math.abs(ball.vy) < 0.005) ball.vy = 0;

  for (var s = 0; s < 4; s++) {
    ball.x += ball.vx / 4;
    resolveWalls('x');
    ball.y += ball.vy / 4;
    resolveWalls('y');
  }

  // Key collection
  for (var i = 0; i < gameKeys.length; i++) {
    if (gameKeys[i].collected) continue;
    var kx = ball.x - gameKeys[i].x, ky = ball.y - gameKeys[i].y;
    if (Math.sqrt(kx * kx + ky * ky) < cellSize * KEY_COLLECT_RADIUS) {
      gameKeys[i].collected = true;
      collectedKeys++;
      keyCollectAnims.push({
        x: gameKeys[i].x, y: gameKeys[i].y,
        startTime: timestamp, duration: 500
      });
      if (collectedKeys >= 3) {
        exitUnlocked = true;
        onExitZone = false;
      }
      updateHUD();
    }
  }

  // Holes
  for (var i = 0; i < holes.length; i++) {
    var h = holes[i];
    var dx = ball.x - h.x, dy = ball.y - h.y;
    if (Math.sqrt(dx * dx + dy * dy) < cellSize * HOLE_FALL_RADIUS) {
      beginFall(h.x, h.y);
      return;
    }
  }

  // Exit check
  var gx = ball.x - endPos.x, gy = ball.y - endPos.y;
  var distToExit = Math.sqrt(gx * gx + gy * gy);
  var exitRadius = cellSize * 0.35;

  if (distToExit < exitRadius) {
    if (!onExitZone) {
      onExitZone = true;
      if (exitUnlocked) {
        onLevelComplete();
      } else {
        messageText = 'üîë Collect all keys first!';
        messageTimer = 1500;
        shakeTimer = 300;
      }
    }
  } else {
    onExitZone = false;
  }
}

function resolveWalls(axis) {
  var r = ball.radius;
  var rows = maze.length, cols = maze[0].length;
  var c0 = Math.max(0, Math.floor((ball.x - r) / cellSize));
  var c1 = Math.min(cols - 1, Math.floor((ball.x + r) / cellSize));
  var r0 = Math.max(0, Math.floor((ball.y - r) / cellSize));
  var r1 = Math.min(rows - 1, Math.floor((ball.y + r) / cellSize));

  for (var row = r0; row <= r1; row++) {
    for (var col = c0; col <= c1; col++) {
      if (maze[row][col] !== WALL) continue;
      var wx = col * cellSize, wy = row * cellSize;
      var cx = Math.max(wx, Math.min(ball.x, wx + cellSize));
      var cy = Math.max(wy, Math.min(ball.y, wy + cellSize));
      var dx = ball.x - cx, dy = ball.y - cy;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < r) {
        if (dist > 0.001) {
          var overlap = r - dist;
          ball.x += (dx / dist) * overlap;
          ball.y += (dy / dist) * overlap;
          if (axis === 'x') ball.vx *= -BOUNCE_FACTOR;
          else ball.vy *= -BOUNCE_FACTOR;
        } else {
          if (axis === 'x') {
            ball.x = ball.vx >= 0 ? wx - r : wx + cellSize + r;
            ball.vx *= -BOUNCE_FACTOR;
          } else {
            ball.y = ball.vy >= 0 ? wy - r : wy + cellSize + r;
            ball.vy *= -BOUNCE_FACTOR;
          }
        }
      }
    }
  }
}

// ============================================================
// FALL ANIMATION
// ============================================================
function beginFall(holeX, holeY) {
  gameState = 'falling';
  timerRunning = false;
  fallAnim = {
    startX: ball.x, startY: ball.y,
    holeX: holeX, holeY: holeY,
    startR: ball.radius,
    startTime: performance.now(),
    duration: 450
  };
}

function tickFallAnimation(timestamp) {
  if (!fallAnim) return;
  var t = Math.min(1, (timestamp - fallAnim.startTime) / fallAnim.duration);
  var ease = t * t;
  var x = fallAnim.startX + (fallAnim.holeX - fallAnim.startX) * ease;
  var y = fallAnim.startY + (fallAnim.holeY - fallAnim.startY) * ease;
  var r = fallAnim.startR * (1 - ease * 0.95);
  drawBall(x, y, r);
  if (t >= 1) { fallAnim = null; onBallFell(); }
}

// ============================================================
// GAME EVENTS
// ============================================================
function onBallFell() {
  lives--;
  updateHUD();
  if (lives <= 0) {
    gameState = 'gameover';
    showOverlay('overlayGameOver');
  } else {
    gameState = 'fell';
    document.getElementById('fellMsg').textContent =
      'Lives remaining: ' + '‚ù§Ô∏è'.repeat(lives);
    showOverlay('overlayFell');
  }
}

function onLevelComplete() {
  gameState = 'win';
  timerRunning = false;
  var elapsed = (performance.now() - timerStart) / 1000;
  totalTime += elapsed;
  document.getElementById('winTime').textContent = elapsed.toFixed(1) + 's';

  if (currentLevel >= LEVELS.length - 1) {
    document.getElementById('totalTimeVal').textContent = totalTime.toFixed(1) + 's';
    gameState = 'alldone';
    showOverlay('overlayAllDone');
  } else {
    document.getElementById('winMsg').textContent =
      'Get ready for Level ' + (currentLevel + 2) + '!';
    showOverlay('overlayWin');
  }
}

// ============================================================
// HUD & OVERLAYS
// ============================================================
function updateHUD() {
  var hearts = '';
  for (var i = 0; i < 3; i++) hearts += i < lives ? '‚ù§Ô∏è' : 'üñ§';
  document.getElementById('hudLives').textContent = hearts;
  document.getElementById('hudLevel').textContent = String(currentLevel + 1);
  document.getElementById('hudKeys').textContent = 'üîë ' + collectedKeys + '/3';
  if (timerRunning) {
    var t = (performance.now() - timerStart) / 1000;
    document.getElementById('hudTime').textContent = t.toFixed(1) + 's';
  }
}

function showOverlay(id) { document.getElementById(id).classList.remove('hidden'); }
function hideAllOverlays() {
  document.querySelectorAll('.overlay').forEach(function(el) { el.classList.add('hidden'); });
}

// ============================================================
// DEVICE ORIENTATION
// ============================================================
function requestMotionPermission(callback) {
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission()
      .then(function(state) {
        if (state === 'granted') { startListening(); callback(); }
      }).catch(console.error);
  } else {
    startListening();
    callback();
  }
}

function startListening() {
  if (orientationListening) return;
  orientationListening = true;
  window.addEventListener('deviceorientation', onDeviceOrientation, true);
}

function onDeviceOrientation(e) {
  var beta = e.beta || 0;
  var gamma = e.gamma || 0;
  if (!calibrated) {
    betaOffset = beta;
    gammaOffset = gamma;
    calibrated = true;
  }
  var adjBeta = beta - betaOffset;
  var adjGamma = gamma - gammaOffset;
  var maxAngle = 25;
  adjBeta = Math.max(-maxAngle, Math.min(maxAngle, adjBeta));
  adjGamma = Math.max(-maxAngle, Math.min(maxAngle, adjGamma));
  tiltX = adjGamma / maxAngle;
  tiltY = adjBeta / maxAngle;
}

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop(timestamp) {
  var dt = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  if (messageTimer > 0) messageTimer -= dt;
  if (shakeTimer > 0) shakeTimer -= dt;

  if (gameState === 'playing') {
    updatePhysics(timestamp);
    updateHUD();
  }

  var shakeX = 0, shakeY = 0;
  if (shakeTimer > 0) {
    var intensity = 4 * (shakeTimer / 300);
    shakeX = (Math.random() - 0.5) * intensity * 2;
    shakeY = (Math.random() - 0.5) * intensity * 2;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(shakeX, shakeY);

  if (bgCanvas) ctx.drawImage(bgCanvas, 0, 0);

  drawExit(timestamp);
  drawKeys(timestamp);

  if (gameState === 'falling') {
    tickFallAnimation(timestamp);
  } else if (gameState === 'playing' || gameState === 'start' ||
             gameState === 'fell' || gameState === 'win') {
    drawBall(ball.x, ball.y, ball.radius);
  }

  ctx.restore();

  drawMessage();

  requestAnimationFrame(gameLoop);
}

// ============================================================
// START / RESTART
// ============================================================
function startPlaying() {
  hideAllOverlays();
  gameState = 'playing';
  timerStart = performance.now();
  timerRunning = true;
  calibrated = false;
}

// ============================================================
// BUTTON HANDLERS
// ============================================================
document.getElementById('btnStart').addEventListener('click', function() {
  requestMotionPermission(function() {
    initLevel();
    startPlaying();
  });
});

document.getElementById('btnRetry').addEventListener('click', function() {
  spawnKeys();
  resetBall();
  startPlaying();
});

document.getElementById('btnNext').addEventListener('click', function() {
  currentLevel++;
  initLevel();
  startPlaying();
});

document.getElementById('btnRestart').addEventListener('click', function() {
  currentLevel = 0; lives = 3; totalTime = 0;
  initLevel();
  startPlaying();
});

document.getElementById('btnPlayAgain').addEventListener('click', function() {
  currentLevel = 0; lives = 3; totalTime = 0;
  initLevel();
  startPlaying();
});

// ============================================================
// LAUNCH
// ============================================================
initLevel();
lastTimestamp = performance.now();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
